from inductor import create_agent

"""Monitor and Understand

- a file-like object will be placed near every working surface
-- for every change detected nearby, that object will try to learn everything about the source short of becoming the source itself
--- every learned differences and counter-factual states (cases) will help guard against anomalous claims about any possible history where it could have been presented in the scope
---- it differentiates itself from everything else that could not allow reconstruction via syndication of that object system by constructing redundant source code near the closure point
----- it captures what could have been given what is apparently present at any given moment
---- it learns what could not possible be achieved from all the knowledge available
--- it can mark trajectories in terms of optimal or organizational
-- 
"""



resource = sample taken from empty room (R, D)

catalog the resource attribute that are usable for transformation tasks
a transformation task would be in terms of a state of static object with known properties whose attributes are reshaped by the constructor thus turning the object attributes into another variable attributes whose properties satisfy the task description.


generic attributes are used for the properties of those values along with a matrix into a system of equations.

this system of linear equations contains the variable whose properties are determined by the convergent into the target state from their generic counterpart.

this constitutes a substrate with its own resource matrix which could be used for arbitrary functions up to the level that is physically possible.


creating a reversible computation task for transforming some generic source into a usable (possible) substrate attributes.

this task is a permutation over the set of at least two parameters defining the substrate attribute.

computing function (C[pi]) over [S] is the union of all x -> pi(x) where x is a possible valid attribute in S.

def compute(permutator, source):
    for x in source:
        y = permutator(x)
        yield union(x, y)




re: <<"""Monitor and Understand...>>
--- continuing this here !


a (samples, channels) matrix with normalized floats
-- (channels, samples) @ (samples, channels) ~ (channels, channels) matrix which is square
--- however this square matrix have large integers along their row/column entries
---- one of the diagonal axis seems to remain invariant
----- that which remains static throughout evolution can be considered as the eigenvectors
------ eigenvectors would have to be the line along with the transformation becomes unitary over k steps
----- the components of that axis are the eigenvalues
---- eigenvalues determined the scale of the changed order at each observable level
--- what are those specific numbers?



(A - lambda * I) * v = 0


(state matrix - scalar function * identity matrix) * action functional = 0

-- finding for which scalar function given the state space collapse everything below one or more levels


let's try to find some equivalent classes:
----- determinants (product of each diagonal elements and difference of the produced components)
---- diagonal matrices (zeros everywhere except for the diagonal path components)
--- change of basis (make columns out of the target basis vectors) (put the inverse of the current basis to the left) and (place on right the current basis as is) ~ the combined linear transformation in effect translates the given basis information in terms of our current basis directly
-- (basis vectors) for which line parameters passing through every cross sections of the perpendicular column spaces such that they remain parallel to each other and perpendicular to every other disjoint axial segment
- (column space) is the space spanned out by the set of basis vectors as row elements whose static constitution over the linear transformation giving dynamical parameters is the result of the computation process

